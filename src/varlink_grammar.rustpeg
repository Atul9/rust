
/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  = #quiet<[ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]> // \v\f removed
  / #expected("whitespace")

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol_r
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

comment
    = #quiet<"#" [^\n\r\u{2028}\u{2029}]* eol_r >

eol
    = #quiet<whitespace* eol_r>
    / #quiet<comment>
    / #expected("<newline>")

__ = #quiet<(whitespace / eol_r / comment)*>

argname
    = [a-z_][A-Za-z0-9_]*

typename
	= [A-Z][A-Za-z0-9_]*

methodname
	= [A-Z][A-Za-z0-9_]*

reversedomainname -> &'input str /* no hyphen at begin and end */
	= #quiet<$( [a-z]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )>
	  / #quiet<$( "xn--" [a-z0-9]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )>
	  / #expected("<reverse domain name>")

array -> usize
    = "[]" { 0 }
    / '[' n:$([0-9]+) ']' {? let v = n.parse::<usize>(); match v { Ok(v) => Ok(v), Err(e) => Err("number 1..18446744073709551615") } }


use super::VType;
use super::VTypeExt;

vtype_maybe_array -> VTypeExt<'input>
    = "bool"       a:array? __ "=" __ v:("true" {true} / "false" {false}) { VTypeExt { vtype: VType::Bool(Some(v)), isarray: a }}
    / "bool"       a:array? { VTypeExt { vtype: VType::Bool(None), isarray: a }}
    / "int"       a:array? __ "=" __ v:$([\+\-0-9]+) {? match v.parse::<i64>(){Ok(v)=>Ok( VTypeExt{vtype: VType::Int(Some(v)), isarray: a}),Err(e)=>Err("int")}}
    / "int"       a:array? { VTypeExt { vtype: VType::Int(None), isarray: a }}
    / "float"    a:array? __ "=" __ v:$([\+\-0-9.,eE]+) {? match v.parse::<f64>(){Ok(v)=>Ok( VTypeExt{vtype: VType::Float(Some(v)), isarray: a}),Err(e)=>Err("float")}}
    / "float"    a:array? { VTypeExt { vtype: VType::Float(None), isarray: a }}
    / "string"     a:array? __ "=" __ '"' v:$( ( '\\' '"' / '\\' / [^"\\] )+ ) '"' { VTypeExt{vtype: VType::VString(Some(v)), isarray: a} }
    / "string"     a:array? { VTypeExt { vtype: VType::VString(None),isarray: a }}
    / t:$(typename)a:array? { VTypeExt { vtype: VType::VTypename(t), isarray: a }}
    / v:vstruct    a:array? { VTypeExt { vtype: VType::VStruct(Box::new(v)), isarray: a }}

use super::Argument;
argument -> Argument<'input>
    = __ n:$(argname) __ ':' __ v:(vtype_maybe_array ++ '|') { Argument { name : n, vtypes : v } }

use super::VStruct;
vstruct -> VStruct<'input>
    = '(' e:argument ** ',' __ ')' { VStruct{ elts: e} }

use super::Typedef;
vtypedef -> Typedef<'input>
    = __ "type" whitespace+ n:$(typename) __ v:vstruct __ { Typedef{name: n, vstruct: v} }

use super::VError;
error -> VError<'input>
    = __ "error" whitespace+ n:$(typename) __ { VError{name: n} }

use super::Method;
method -> Method<'input>
    = __ "method" whitespace+ n:$(methodname) __ i:vstruct __ s:("-" { false } / "=" { true }) ">" __ o:vstruct __ { Method{name: n, input: i, output: o, stream: s} }

use super::MethodOrTypedefOrError;
method_or_vtypedef_or_error -> MethodOrTypedefOrError<'input>
    = m:method { MethodOrTypedefOrError::Method(m) }
    / t:vtypedef { MethodOrTypedefOrError::Typedef(t) }
    / e:error { MethodOrTypedefOrError::Error(e) }

use super::Interface;
pub VInterface -> Interface<'input>
	= __ "interface" whitespace+ n:$reversedomainname eol mt:(method_or_vtypedef_or_error*) __  { Interface::from_token(n, mt) }