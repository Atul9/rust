
/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}] // \v\f removed

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

comment
    = "/*" ( [^*] / ([*]+ [^*/] ) )* [*]+ '/'

docstring
    = "/**" ( [^*] / ([*]+ [^*/] ) )* [*]+ '/'

__ = (whitespace / eol / comment / docstring )*

argname
    = [a-z_][A-Za-z0-9_]*

typename
	= [A-Z][A-Za-z0-9_]*

methodname
	= [A-Z][A-Za-z0-9_]*

reversedomainname -> &'input str /* no hyphen at begin and end */
	= $( [a-z]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )
	  / $( "xn--" [a-z0-9]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )

vtype -> VType<'input>
    = "bool"     { VType::Bool }
    / "int8"     { VType::Int8 }
    / "uint8"    { VType::UInt8 }
    / "int16"    { VType::Int16 }
    / "uint16"   { VType::UInt16 }
    / "int32"    { VType::Int32 }
    / "uint32"   { VType::UInt32 }
    / "int64"    { VType::Int64 }
    / "uint64"   { VType::UInt64 }
    / "float32"  { VType::Float32 }
    / "float64"  { VType::Float64 }
    / "string"   { VType::VString }
    / n:$(typename)   { VType::VTypename(n) }
    / v:vstruct    { VType::VStruct(Box::new(v)) }

array -> Option<usize>
    = '[' n:$([0-9]*) ']' { if n.len() == 0 { None } else { Some(str::parse::<usize>(n).unwrap()) }}

nullable
    = '?'

vtype_maybe_array -> VTypeExt<'input>
    = v:vtype a:array? n:nullable? { VTypeExt { vtype: v, nullable: { match n { Some(_) => true, None => false } }, isarray: a }}

argument -> Argument<'input>
    = __ n:$(argname) __ ':' __ v:(vtype_maybe_array ++ '|') { Argument { name : n, vtypes : v } }

vstruct -> VStruct<'input>
    = '(' e:argument ** ',' __ ')' { VStruct{ elts: e} }

vtypedef -> Typedef<'input>
    = __ "type" (comment / docstring)* whitespace __ n:$(typename) __ v:vstruct __ { Typedef{name: n, vstruct: v} }

method -> Method<'input>
    = __ n:$(methodname) __ i:vstruct __ s:("-" { false } / "=" { true }) ">" __ o:vstruct __ { Method{name: n, input: i, output: o, stream: s} }

methord_or_vtypedef -> MethodOrTypedef<'input>
    = m:method { MethodOrTypedef::Method(m) }
    / t:vtypedef { MethodOrTypedef::Typedef(t) }

interface -> Interface<'input>
	= __ n:$reversedomainname __ '{' ts:(vtypedef*) m:method mt:(methord_or_vtypedef*) __ '}' __ { Interface::from_token(n, ts, m, mt) }

#[export]
interfaces -> Vec<Interface<'input>>
    = interface+
