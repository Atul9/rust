/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace -> ()
  = #quiet<[ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]> // \v\f removed
  / #expected("whitespace")

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol_r -> ()
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

comment -> ()
    = #quiet<"#" [^\n\r\u{2028}\u{2029}]* eol_r >
    / #expected("<comment>")

eol -> ()
    = #quiet<whitespace* eol_r>
    / #quiet<comment>
    / #expected("<newline>")

_ -> ()
    = #quiet<whitespace / comment / eol_r>
    / #expected("<newline> <whitespace> or <comment>")

field_name
    = [a-z_][A-Za-z0-9_]*

name
	= [A-Z][A-Za-z0-9_]*

interface_name -> &'input str /* no hyphen at begin and end */
	= #quiet<$( [a-z]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )>
	  / #quiet<$( "xn--" [a-z0-9]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )>
	  / #expected("<reverse domain name>")

array -> usize
    = "[]" { 0 }
    / '[' n:$([0-9]+) ']' {? let v = n.parse::<usize>(); match v { Ok(v) => Ok(v), Err(e) => Err("number 1..18446744073709551615") } }


use super::VType;
use super::VTypeExt;

type -> VTypeExt<'input>
    = "bool"    a:array? _* "=" _* v:("true" {true} / "false" {false}) { VTypeExt { vtype: VType::Bool(Some(v)), isarray: a }}
    / "bool"    a:array? { VTypeExt { vtype: VType::Bool(None), isarray: a }}
    / "int"     a:array? _* "=" _* v:$([\+\-0-9]+) {? match v.parse::<i64>(){Ok(v)=>Ok( VTypeExt{vtype: VType::Int(Some(v)), isarray: a}),Err(e)=>Err("int")}}
    / "int"     a:array? { VTypeExt { vtype: VType::Int(None), isarray: a }}
    / "float"   a:array? _* "=" _* v:$([\+\-0-9.,eE]+) {? match v.parse::<f64>(){Ok(v)=>Ok( VTypeExt{vtype: VType::Float(Some(v)), isarray: a}),Err(e)=>Err("float")}}
    / "float"   a:array? { VTypeExt { vtype: VType::Float(None), isarray: a }}
    / "string"  a:array? _* "=" _* '"' v:$( ( '\\' '"' / '\\' / [^"\\] )+ ) '"' { VTypeExt{vtype: VType::VString(Some(v)), isarray: a} }
    / "string"  a:array? { VTypeExt { vtype: VType::VString(None),isarray: a }}
    / "data"    a:array? _* "=" _* '"' v:$( ( '\\' '"' / '\\' / [^"\\] )+ ) '"' { VTypeExt{vtype: VType::VData(Some(v)), isarray: a} }
    / "data"    a:array? { VTypeExt { vtype: VType::VData(None),isarray: a }}
    / t:$(name) a:array? { VTypeExt { vtype: VType::VTypename(t), isarray: a }}
    / v:vstruct a:array? { VTypeExt { vtype: VType::VStruct(Box::new(v)), isarray: a }}

use super::Argument;
argument -> Argument<'input>
    = _* n:$(field_name) _* ':' _* v:(type ++ ',' ) { Argument { name : n, vtypes : v } }

use super::VStruct;
vstruct -> VStruct<'input>
    = '(' e:argument ** ',' _* ')' { VStruct{ elts: e} }

use super::Typedef;
vtypedef -> Typedef<'input>
    = "type" _+ n:$(name) _* v:vstruct { Typedef{name: n, vstruct: v} }

use super::VError;
error -> VError<'input>
    = "error" _+ n:$(name) { VError{name: n} }

use super::Method;
method -> Method<'input>
    = "method" _+ n:$(name) _* i:vstruct _* "->" _* o:vstruct { Method{name: n, input: i, output: o} }

use super::MethodOrTypedefOrError;
member -> MethodOrTypedefOrError<'input>
    = _* m:method { MethodOrTypedefOrError::Method(m) }
    / _* t:vtypedef { MethodOrTypedefOrError::Typedef(t) }
    / _* e:error { MethodOrTypedefOrError::Error(e) }

use super::Interface;
pub VInterface -> Interface<'input>
	= _* "interface" _+ n:$interface_name eol mt:(member++ eol) _*  { Interface::from_token(n, mt) }