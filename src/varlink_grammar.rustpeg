
/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  = #quiet<[ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]> // \v\f removed
  / #expected("whitespace")

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol_r
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

eol
    = #quiet<(whitespace / comment / docstring )* eol_r>
    / #expected("<newline>")

comment
    = #quiet<"/*" ( [^*] / ([*]+ [^*/] ) )* [*]+ '/'>

docstring
    = #quiet<"/**" ( [^*] / ([*]+ [^*/] ) )* [*]+ '/'>

__ = #quiet<(whitespace / eol_r / comment / docstring )*>

argname
    = [a-z_][A-Za-z0-9_]*

typename
	= [A-Z][A-Za-z0-9_]*

methodname
	= [A-Z][A-Za-z0-9_]*

reversedomainname -> &'input str /* no hyphen at begin and end */
	= #quiet<$( [a-z]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )>
	  / #quiet<$( "xn--" [a-z0-9]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )>
	  / #expected("<reverse domain name>")

array -> usize
    = "[]" { 0 }
    / '[' n:$([0-9]+) ']' {? let v = n.parse::<usize>(); match v { Ok(v) => Ok(v), Err(e) => Err("number 1..18446744073709551615") } }

nullable -> bool
    = '?' {true}
    / ""  {false}

use super::VType;
use super::VTypeExt;

vtype_maybe_array -> VTypeExt<'input>
    = "bool"       a:array? n:nullable { VTypeExt { vtype: VType::Bool(None), nullable: n, isarray: a }}
    / "int8"       a:array? n:nullable { VTypeExt { vtype: VType::Int8(None), nullable: n, isarray: a }}
    / "uint8"      a:array? n:nullable { VTypeExt { vtype: VType::UInt8(None), nullable: n, isarray: a }}
    / "int16"      a:array? n:nullable { VTypeExt { vtype: VType::Int16(None), nullable: n, isarray: a }}
    / "uint16"     a:array? n:nullable { VTypeExt { vtype: VType::UInt16(None), nullable: n, isarray: a }}
    / "int32"      a:array? n:nullable { VTypeExt { vtype: VType::Int32(None), nullable: n, isarray: a }}
    / "uint32"     a:array? n:nullable { VTypeExt { vtype: VType::UInt32(None), nullable: n, isarray: a }}
    / "int64"      a:array? n:nullable { VTypeExt { vtype: VType::Int64(None), nullable: n, isarray: a }}
    / "uint64"     a:array? n:nullable { VTypeExt { vtype: VType::UInt64(None), nullable: n, isarray: a }}
    / "float32"    a:array? n:nullable { VTypeExt { vtype: VType::Float32(None), nullable: n, isarray: a }}
    / "float64"    a:array? n:nullable { VTypeExt { vtype: VType::Float64(None), nullable: n, isarray: a }}
    / "string"     a:array? n:nullable { VTypeExt { vtype: VType::VString(None), nullable: n, isarray: a }}
    / t:$(typename)a:array? n:nullable { VTypeExt { vtype: VType::VTypename(t), nullable: n, isarray: a }}
    / v:vstruct    a:array? n:nullable { VTypeExt { vtype: VType::VStruct(Box::new(v)), nullable: n, isarray: a }}


use super::Argument;

argument -> Argument<'input>
    = __ n:$(argname) __ ':' __ v:(vtype_maybe_array ++ '|') { Argument { name : n, vtypes : v } }

use super::VStruct;
vstruct -> VStruct<'input>
    = '(' e:argument ** ',' __ ')' { VStruct{ elts: e} }

use super::Typedef;
vtypedef -> Typedef<'input>
    = __ "type" (whitespace/eol)+ __ n:$(typename) __ v:vstruct __ { Typedef{name: n, vstruct: v} }

use super::Method;
method -> Method<'input>
    = __ n:$(methodname) __ i:vstruct __ s:("-" { false } / "=" { true }) ">" __ o:vstruct __ { Method{name: n, input: i, output: o, stream: s} }

use super::MethodOrTypedef;
methord_or_vtypedef -> MethodOrTypedef<'input>
    = m:method { MethodOrTypedef::Method(m) }
    / t:vtypedef { MethodOrTypedef::Typedef(t) }

use super::Interface;
interface -> Interface<'input>
	= __ n:$reversedomainname __ '{' mt:(methord_or_vtypedef*) __ '}' __  { Interface::from_token(n, mt) }

pub Interfaces -> Vec<Interface<'input>>
    = interface+
