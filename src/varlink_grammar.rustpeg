
/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}] // \v\f removed

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

comment
    = "/*" ( [^*] / ([*]+ [^*/] ) )* [*]+ '/'

docstring
    = "/**" ( [^*] / ([*]+ [^*/] ) )* [*]+ '/'

__ = (whitespace / eol / comment / docstring )*

argname
    = [a-z_][A-Za-z0-9_]*

typename
	= [A-Z][A-Za-z0-9_]*

methodname
	= [A-Z][A-Za-z0-9_]*

reversedomainname -> &'input str /* no hyphen at begin and end */
	= $( [a-z]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )
	  / $( "xn--" [a-z0-9]+ ( '.' [a-z0-9]+ ([-] [a-z0-9]+)* )+ )

vtype
    = "bool"
    / "int8" / "uint8" / "int16" / "uint16" / "int32" / "uint32"
    / "int64" / "uint64" / "float32" / "float64" / "string"
    / typename
    / vstruct

array
    = '[' [0-9]* ']'

nullable
    = '?'

vtype_maybe_array
    = vtype array? nullable?

/* at least one and maybe multiple vtype_maybe_array separated by | */
vtype_maybe_union
    = vtype_maybe_array ++ '|'

argument
    = __ argname __ ':' __ vtype_maybe_union

vstruct
    = '(' argument ** ',' __ ')'

vtypedef -> Typedef<'input>
    = __ "type" (comment / docstring)* whitespace __ n:$(typename) __ vstruct __ { Typedef{name: n} }

method -> Method<'input>
    = __ n:$(methodname) __ vstruct __ "->" __ vstruct __ { Method{name: n} }

methord_or_vtypedef -> MethodOrTypedef<'input>
    = m:method { MethodOrTypedef::Method(m) }
    / t:vtypedef { MethodOrTypedef::Typedef(t) }

interface -> Interface<'input>
	= __ n:$reversedomainname __ '{' ts:(vtypedef*) m:method mt:(methord_or_vtypedef*) __ '}' __ { Interface::from_token(n, ts, m, mt) }

#[export]
interfaces -> Vec<Interface<'input>>
    = interface+

