use serde_derive :: { { Deserialize , Serialize } } ; use failure :: { { Backtrace , Context , Fail } } ; use serde_json ; use std :: io :: BufRead ; use std :: sync :: { { Arc , RwLock } } ; use varlink :: { { self , CallTrait } } ; # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#Enum { r#enum , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#Interface { r#interface , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#Type { r#type , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#TypeEnum { r#type , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#TypeFoo_enum { r#foo , r#bar , r#baz , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#TypeFoo_anon_baz { pub r#a : i64 , pub r#b : i64 , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#TypeFoo_anon { pub r#foo : bool , pub r#bar : i64 , pub r#baz : Vec < TypeFoo_anon_baz > , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#TypeFoo { pub r#bool : bool , pub r#int : i64 , pub r#float : f64 , pub r#string : String , pub r#enum : Option < varlink :: StringHashMap < Option < TypeFoo_enum >>> , pub r#type : Option < TypeEnum > , pub r#anon : TypeFoo_anon , pub r#object : serde_json :: Value , pub r#stringset : varlink :: StringHashSet , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct ErrorBar_Args { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#ErrorFoo_Args_enum { pub r#b : bool , pub r#c : i64 , pub r#interface : Interface , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#ErrorFoo_Args_bar { r#type , r#enum , r#int , r#bool , r#string , r#if , r#let , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct ErrorFoo_Args { pub r#enum : ErrorFoo_Args_enum , pub r#foo : TypeFoo , pub r#bar : ErrorFoo_Args_bar , pub r#interface : Interface , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#ErrorFoo_Args_enum { pub r#b : bool , pub r#c : i64 , pub r#interface : Interface , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#ErrorFoo_Args_bar { r#type , r#enum , r#int , r#bool , r#string , r#if , r#let , } pub trait VarlinkCallError : varlink :: CallTrait { fn reply_error_bar ( & mut self , ) -> varlink :: Result < ( ) > { self . reply_struct ( varlink :: Reply :: error ( "org.example.complex.ErrorBar" , None ) ) } fn reply_error_foo ( & mut self , r#enum : ErrorFoo_Args_enum , r#foo : TypeFoo , r#bar : ErrorFoo_Args_bar , r#interface : Interface ) -> varlink :: Result < ( ) > { self . reply_struct ( varlink :: Reply :: error ( "org.example.complex.ErrorFoo" , Some ( serde_json :: to_value ( ErrorFoo_Args { r#enum , r#foo , r#bar , r#interface } ) ? ) ) ) } } impl < 'a > VarlinkCallError for varlink :: Call < 'a > { } # [ derive ( Debug ) ] pub struct Error { inner : Context < ErrorKind > , } # [ derive ( Clone , PartialEq , Debug , Fail ) ] pub enum ErrorKind { # [ fail ( display = "IO error" ) ] Io_Error ( :: std :: io :: ErrorKind ) , # [ fail ( display = "(De)Serialization Error" ) ] SerdeJson_Error ( serde_json :: error :: Category ) , # [ fail ( display = "Varlink Error" ) ] Varlink_Error ( varlink :: ErrorKind ) , # [ fail ( display = "Unknown error reply: '{:#?}'" , _0 ) ] VarlinkReply_Error ( varlink :: Reply ) , # [ fail ( display = "org.example.complex.ErrorBar: {:#?}" , _0 ) ] ErrorBar ( Option < ErrorBar_Args > ) , # [ fail ( display = "org.example.complex.ErrorFoo: {:#?}" , _0 ) ] ErrorFoo ( Option < ErrorFoo_Args > ) } impl Fail for Error { fn cause ( & self ) -> Option < & Fail > { self . inner . cause ( ) } fn backtrace ( & self ) -> Option < & Backtrace > { self . inner . backtrace ( ) } } impl :: std :: fmt :: Display for Error { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { :: std :: fmt :: Display :: fmt ( & self . inner , f ) } } impl Error { # [ allow ( dead_code ) ] pub fn kind ( & self ) -> ErrorKind { self . inner . get_context ( ) . clone ( ) } } impl From < ErrorKind > for Error { fn from ( kind : ErrorKind ) -> Error { Error { inner : Context :: new ( kind ) , } } } impl From < Context < ErrorKind >> for Error { fn from ( inner : Context < ErrorKind > ) -> Error { Error { inner } } } impl From < :: std :: io :: Error > for Error { fn from ( e : :: std :: io :: Error ) -> Error { let kind = e . kind ( ) ; e . context ( ErrorKind :: Io_Error ( kind ) ) . into ( ) } } impl From < serde_json :: Error > for Error { fn from ( e : serde_json :: Error ) -> Error { let cat = e . classify ( ) ; e . context ( ErrorKind :: SerdeJson_Error ( cat ) ) . into ( ) } } # [ allow ( dead_code ) ] pub type Result < T > = :: std :: result :: Result < T , Error > ; impl From < varlink :: Error > for Error { fn from ( e : varlink :: Error ) -> Self { let kind = e . kind ( ) ; match kind { varlink :: ErrorKind :: Io ( kind ) => e . context ( ErrorKind :: Io_Error ( kind ) ) . into ( ) , varlink :: ErrorKind :: SerdeJsonSer ( cat ) => e . context ( ErrorKind :: SerdeJson_Error ( cat ) ) . into ( ) , kind => e . context ( ErrorKind :: Varlink_Error ( kind ) ) . into ( ) , } } } impl From < varlink :: Reply > for Error { fn from ( e : varlink :: Reply ) -> Self { if varlink :: Error :: is_error ( & e ) { return varlink :: Error :: from ( e ) . into ( ) ; } match e { varlink :: Reply { error : Some ( ref t ) , .. } if t == "org.example.complex.ErrorBar" => { match e { varlink :: Reply { parameters : Some ( p ) , .. } => match serde_json :: from_value ( p ) { Ok ( v ) => ErrorKind :: ErrorBar ( v ) . into ( ) , Err ( _ ) => ErrorKind :: ErrorBar ( None ) . into ( ) , } , _ => ErrorKind :: ErrorBar ( None ) . into ( ) , } } varlink :: Reply { error : Some ( ref t ) , .. } if t == "org.example.complex.ErrorFoo" => { match e { varlink :: Reply { parameters : Some ( p ) , .. } => match serde_json :: from_value ( p ) { Ok ( v ) => ErrorKind :: ErrorFoo ( v ) . into ( ) , Err ( _ ) => ErrorKind :: ErrorFoo ( None ) . into ( ) , } , _ => ErrorKind :: ErrorFoo ( None ) . into ( ) , } } _ => ErrorKind :: VarlinkReply_Error ( e ) . into ( ) , } } } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Bar_Reply { } impl varlink :: VarlinkReply for Bar_Reply { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Bar_Args { } pub trait Call_Bar : VarlinkCallError { fn reply ( & mut self ) -> varlink :: Result < ( ) > { self . reply_struct ( varlink :: Reply :: parameters ( None ) ) } } impl < 'a > Call_Bar for varlink :: Call < 'a > { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#Foo_Args_enum { pub r#b : bool , pub r#c : i64 , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#Foo_Reply_a { pub r#b : bool , pub r#c : i64 , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Foo_Reply { pub r#a : Vec < Foo_Reply_a > , pub r#foo : TypeFoo , pub r#interface : Interface , } impl varlink :: VarlinkReply for Foo_Reply { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Foo_Args { pub r#enum : Foo_Args_enum , pub r#foo : TypeFoo , pub r#interface : Interface , } pub trait Call_Foo : VarlinkCallError { fn reply ( & mut self , r#a : Vec < Foo_Reply_a > , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: Result < ( ) > { self . reply_struct ( Foo_Reply { r#a , r#foo , r#interface } . into ( ) ) } } impl < 'a > Call_Foo for varlink :: Call < 'a > { } pub trait VarlinkInterface { fn bar ( & self , call : & mut Call_Bar , ) -> varlink :: Result < ( ) > ; fn foo ( & self , call : & mut Call_Foo , r#enum : Foo_Args_enum , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: Result < ( ) > ; fn call_upgraded ( & self , _call : & mut varlink :: Call , _bufreader : & mut BufRead ) -> varlink :: Result < Vec < u8 >> { Ok ( Vec :: new ( ) ) } } pub trait VarlinkClientInterface { fn bar ( & mut self , ) -> varlink :: MethodCall < Bar_Args , Bar_Reply , Error > ; fn foo ( & mut self , r#enum : Foo_Args_enum , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: MethodCall < Foo_Args , Foo_Reply , Error > ; } # [ allow ( dead_code ) ] pub struct VarlinkClient { connection : Arc < RwLock < varlink :: Connection >> , } impl VarlinkClient { # [ allow ( dead_code ) ] pub fn new ( connection : Arc < RwLock < varlink :: Connection >> ) -> Self { VarlinkClient { connection , } } } impl VarlinkClientInterface for VarlinkClient { fn bar ( & mut self , ) -> varlink :: MethodCall < Bar_Args , Bar_Reply , Error > { varlink :: MethodCall :: < Bar_Args , Bar_Reply , Error > :: new ( self . connection . clone ( ) , "org.example.complex.Bar" , Bar_Args { } ) } fn foo ( & mut self , r#enum : Foo_Args_enum , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: MethodCall < Foo_Args , Foo_Reply , Error > { varlink :: MethodCall :: < Foo_Args , Foo_Reply , Error > :: new ( self . connection . clone ( ) , "org.example.complex.Foo" , Foo_Args { r#enum , r#foo , r#interface } ) } } # [ allow ( dead_code ) ] pub struct VarlinkInterfaceProxy { inner : Box < VarlinkInterface + Send + Sync > , } # [ allow ( dead_code ) ] pub fn new ( inner : Box < VarlinkInterface + Send + Sync > ) -> VarlinkInterfaceProxy { VarlinkInterfaceProxy { inner } } impl varlink :: Interface for VarlinkInterfaceProxy { fn get_description ( & self ) -> & 'static str { "interface org.example.complex\n\ntype Enum (enum, b, c)\n\ntype Type (type, b, c)\n\ntype TypeEnum (type, b, c)\n\ntype Interface (interface, b, c)\n\ntype TypeFoo (\n  bool: bool,\n  int: int,\n  float: float,\n  string: string,\n  enum: ?[string]?(foo, bar, baz),\n  type: ?TypeEnum,\n  anon: (\n    foo: bool,\n    bar: int,\n    baz: [](a: int, b: int)\n  ),\n  object: object,\n  stringset: [string]()\n)\n\nmethod Foo(\n  enum: (b: bool, c: int),\n  foo: TypeFoo,\n  interface: Interface\n) -> (\n  a: [](b: bool, c: int),\n  foo: TypeFoo,\n  interface: Interface\n)\n\nmethod Bar() -> ()\n\nerror ErrorFoo (\n  enum: (\n    b: bool,\n    c: int,\n    interface: Interface\n  ),\n  foo: TypeFoo,\n  bar: (type, enum, int, bool, string, if, let),\n  interface: Interface\n)\n\nerror ErrorBar ()\n" } fn get_name ( & self ) -> & 'static str { "org.example.complex" } fn call_upgraded ( & self , call : & mut varlink :: Call , bufreader : & mut BufRead ) -> varlink :: Result < Vec < u8 >> { self . inner . call_upgraded ( call , bufreader ) } fn call ( & self , call : & mut varlink :: Call ) -> varlink :: Result < ( ) > { let req = call . request . unwrap ( ) ; match req . method . as_ref ( ) { "org.example.complex.Bar" => self . inner . bar ( call as & mut Call_Bar ) , "org.example.complex.Foo" => { if let Some ( args ) = req . parameters . clone ( ) { let args : Foo_Args = match serde_json :: from_value ( args ) { Ok ( v ) => v , Err ( e ) => { let es = format ! ( "{}" , e ) ; let _ = call . reply_invalid_parameter ( es . clone ( ) ) ; return Err ( varlink :: ErrorKind :: SerdeJsonDe ( es ) . into ( ) ) ; } } ; self . inner . foo ( call as & mut Call_Foo , args . r#enum , args . r#foo , args . r#interface ) } else { call . reply_invalid_parameter ( "parameters" . into ( ) ) } } , m => { call . reply_method_not_found ( String :: from ( m ) ) } } } }