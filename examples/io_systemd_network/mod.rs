// This file is automatically generated by the varlink rust generator
use std::convert::From;
use std::io;

use varlink;
use serde_json;

#[derive(Serialize, Deserialize, Debug)]
pub struct Netdev {
    pub ifindex: Option<i64>,
    pub ifname: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NetdevInfo {
    pub ifindex: Option<i64>,
    pub ifname: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct InfoReply {
    pub info: Option<NetdevInfo>,
}
impl varlink::server::VarlinkReply for InfoReply {}

#[derive(Serialize, Deserialize, Debug)]
pub struct InfoArgs {
    pub ifindex: Option<i64>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ListReply {
    pub netdevs: Option<Vec<Netdev>>,
}
impl varlink::server::VarlinkReply for ListReply {}

#[derive(Serialize, Deserialize, Debug)]
pub struct UnknownErrorArgs {
    pub text: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct UnknownNetworkIfIndexArgs {
    pub ifindex: Option<i64>,
}

#[derive(Debug)]
pub enum Error {
    UnknownError(Option<UnknownErrorArgs>),
    UnknownNetworkIfIndex(Option<UnknownNetworkIfIndexArgs>),
}
/*
pub struct Call<'a> {
    inner: &'a mut varlink::server::Call<'a>,
}

impl<'a> Call<'a> {
    pub fn reply_info(&self, args: &InfoReply) -> io::Result<()> {
        return self.inner.reply_parameters(serde_json::to_value(args)?);
    }
    pub fn reply_list(&self, args: &ListReply) -> io::Result<()> {
        return self.inner.reply_parameters(serde_json::to_value(args)?);
    }
    pub fn reply_error(&mut self, err: Error) -> io::Result<()> {
        return self.inner.reply(err.into());
    }
}
*/

impl From<Error> for varlink::server::Reply {
    fn from(e: Error) -> Self {
        varlink::server::Reply::error(match e {
                                          Error::UnknownError(_) => {
                                              "io.systemd.network.UnknownError".into()
                                          }
                                          Error::UnknownNetworkIfIndex(_) => {
                                              "io.systemd.network.UnknownNetworkIfIndex".into()
                                          }
                                      },
                                      match e {
                                          Error::UnknownError(args) => {
                                              Some(serde_json::to_value(args).unwrap())
                                          }
                                          Error::UnknownNetworkIfIndex(args) => {
                                              Some(serde_json::to_value(args).unwrap())
                                          }
                                      })
    }
}

pub trait Interface {
    fn info(&self, &mut varlink::server::Call, ifindex: Option<i64>) -> io::Result<()>;
    fn list(&self, &mut varlink::server::Call) -> io::Result<()>;
}

pub struct InterfaceImpl {
    inner: Box<Interface>,
}

pub fn new(inner: Box<Interface>) -> Box<InterfaceImpl> {
    Box::new(InterfaceImpl { inner })
}

impl varlink::server::Interface for InterfaceImpl {
    fn get_description(&self) -> &'static str {
        r#"
# Provides information about network state
interface io.systemd.network

type NetdevInfo (
  ifindex: int,
  ifname: string
)

type Netdev (
  ifindex: int,
  ifname: string
)

# Returns information about a network device
method Info(ifindex: int) -> (info: NetdevInfo)

# Lists all network devices
method List() -> (netdevs: Netdev[])

error UnknownNetworkDevice ()
error UnknownError (text: string)
"#
    }

    fn get_name(&self) -> &'static str {
        "io.systemd.network"
    }

    fn call(&self, call: &mut varlink::server::Call) -> io::Result<()> {
        let method = call.request.method.clone();
        match method.as_ref() {
            "io.systemd.network.Info" => {
                if let Some(args) = call.request.parameters.clone() {
                    let args: InfoArgs = serde_json::from_value(args)?;
                    return self.inner.info(call, args.ifindex);
                } else {
                    return call.reply(varlink::server::VarlinkError::InvalidParameter(None).into());
                }
            }
            "io.systemd.network.List" => return self.inner.list(call),
            m => {
                let method: String = m.clone().into();
                return call.reply(varlink::server::VarlinkError::MethodNotFound(Some(method
                                                                                         .into()))
                                      .into());
            }
        }
    }
}
