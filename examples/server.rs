extern crate serde_json;
#[macro_use]
extern crate serde_derive;
use std::io;
use std::thread;

extern crate varlink;

use varlink::server::VarlinkService;
use std::sync::{Arc, RwLock};
use std::net::{Shutdown, TcpListener};

mod io_systemd_network {
    // will be autogenerated by the above macro in the future
    include!("io_systemd_network/mod.rs");
}

use io_systemd_network::*;

struct MyServer {
    pub state: Arc<RwLock<i64>>,
}

impl io_systemd_network::Interface for MyServer {
    fn info(&self, call: &mut varlink::server::Call, i: Option<i64>) -> io::Result<()> {
        // State example
        {
            let mut number = self.state.write().unwrap();

            *number += 1;

            println!("{}", *number);
        }
        println!("Call: {:?}", call.request);
        match i {
            Some(1) => {
                return call.reply(
                    InfoReply {
                        info: Some(NetdevInfo {
                            ifindex: Some(1),
                            ifname: Some("lo".into()),
                        }),
                    }.into(),
                )
            }
            Some(2) => {
                return call.reply(
                    InfoReply {
                        info: Some(NetdevInfo {
                            ifindex: Some(2),
                            ifname: Some("eth0".into()),
                        }),
                    }.into(),
                )
            }
            _ => {
                return call.reply(Error::UnknownNetworkIfIndex(Some(UnknownNetworkIfIndexArgs {
                                                                        ifindex: i,
                                                                    })).into())
            }
        }
    }

    fn list(&self, call: &mut varlink::server::Call) -> io::Result<()> {
        // State example
        {
            let mut number = self.state.write().unwrap();

            *number -= 1;

            println!("{}", *number);
        }
        println!("Call: {:?}", call.request);
        call.reply_more(
            ListReply {
                netdevs: Some(vec![Netdev {
                         ifindex: Some(1),
                         ifname: Some("lo".into()),
                     }]),
            }.into(),
        )?;

        return call.reply(
            ListReply {
                netdevs: Some(vec![Netdev {
                         ifindex: Some(1),
                         ifname: Some("lo".into()),
                     },
                     Netdev {
                         ifindex: Some(2),
                         ifname: Some("eth0".into()),
                     }]),
            }.into(),
        );
    }
}

fn main() {
    let _join = thread::spawn(|| -> io::Result<()> {
        let addr = "0.0.0.0:12345";
        let listener = TcpListener::bind(addr).unwrap();
        let state = Arc::new(RwLock::new(0));
        println!("Listening on {}", addr);
        let myserver = MyServer { state };
        let myintf = io_systemd_network::new(myserver);
        let server = VarlinkService::new("org.varlink",
                                         "test service",
                                         "0.1",
                                         "http://varlink.org",
                                         vec![myintf.clone()]);

        loop {
            let (mut stream, _addr) = listener.accept()?;
            let server = server.clone();
            let _join = thread::spawn(move || -> io::Result<()> {
                let mut stream_clone = stream.try_clone().expect("clone failed...");
                if let Err(e) = server.handle(&mut stream, &mut stream_clone) {
                    println!("Handle Error: {}", e);
                }
                if let Err(e) = stream.shutdown(Shutdown::Both) {
                    println!("Shutdown Error: {}", e);
                }
                Ok(())
            });
        }

    }).join()
        .unwrap();
}
