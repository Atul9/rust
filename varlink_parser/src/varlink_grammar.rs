#![cfg(not(feature="dynamic_peg"))]

// Generated by rust-peg. Do not edit.
use self::RuleResult::{Matched, Failed};
use super::VType;
use super::VTypeExt;
use super::Argument;
use super::VStruct;
use super::VEnum;
use super::Typedef;
use super::VStructOrEnum;
use super::trim_doc;
use super::VError;
use super::Method;
use super::MethodOrTypedefOrError;
use super::Interface;

fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}

fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos =
        pos + c.len_utf8();
    (*c, next_pos)
}

#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed }

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::
    std::collections::HashSet<&'static str>,
}

pub type ParseResult<T> = Result<T, ParseError>;

impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::result
    ::Result<(), ::std::fmt::Error> {
        try!(
            write!(fmt, "error at {}:{}: expected ", self.line, self.column))
        ;
        if self.expected.is_empty() { try!(write!(fmt, "EOF")); } else if self.expected.len() == 1 {
            try!(
                write!(
                    fmt, "`{}`", escape_default(
                        self.expected.iter().next().unwrap())));
        } else {
            let mut iter = self.expected.iter();
            try!(
                write!(
                    fmt, "one of `{}`", escape_default(iter.next().unwrap())));
            for elem in iter {
                try!(write!(fmt, ", `{}`", escape_default(elem)));
            }
        }
        Ok(()
        )
    }
}

impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}

fn slice_eq(
    input: &str, state: &mut ParseState, pos: usize, m: &'static str)
    -> RuleResult<()> {
    #![inline] #![allow(dead_code)] let l = m.len();
    if input.
        len() >= pos + l && &input.as_bytes()[pos..pos + l] == m.
        as_bytes() { Matched(pos + l, ()) } else {
        state.mark_failure(pos, m)
    }
}

fn slice_eq_case_insensitive(
    input: &str, state: &mut ParseState, pos: usize, m: &'static str)
    -> RuleResult<()> {
    #![inline] #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(
        |x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map
    (|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.
            next();
        if input_char_result.is_none() || input_char_result.unwrap
        () != m_char_upper { return state.mark_failure(pos, m); }
    }
    Matched(
        pos + used, ())
}

fn any_char(
    input: &str, state: &mut ParseState, pos: usize) -> RuleResult<()
> {
    #![inline] #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}

fn pos_to_line(
    input: &str, pos: usize) -> (usize, usize) {
    let before = &input[..pos];
    let line = before.as_bytes().iter().filter(|&&c| c == b'\n').count() + 1;
    let col = before.chars
    ().rev().take_while(|&c| c != '\n').count() + 1;
    (
        line, col)
}

impl<'input> ParseState<'input> {
    fn mark_failure(&mut self, pos: usize, expected: &'static str) ->
    RuleResult<()> {
        if self.suppress_fail == 0 {
            if pos > self.max_err_pos {
                self.max_err_pos = pos;
                self.expected.clear();
            }
            if pos == self.
                max_err_pos { self.expected.insert(expected); }
        }
        Failed
    }
}

struct ParseState<'input> { max_err_pos: usize, suppress_fail: usize, expected: ::std::collections::HashSet<&'static str>, _phantom: ::std::marker::PhantomData<&'input ()> }

impl<'input> ParseState<'input> { fn new() -> ParseState<'input> { ParseState { max_err_pos: 0, suppress_fail: 0, expected: ::std::collections::HashSet::new(), _phantom: ::std::marker::PhantomData } } }

fn __parse_whitespace<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = {
                let str_start = __pos;
                match if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        ' ' | '\t' | '\u{a0}' | '\u{feff}' | '\u{1680}' | '\u{180e}' | '\u{2000}'...'\u{200a}' | '\u{202f}' | '\u{205f}' | '\u{3000}' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]"),
                    }
                } else { __state.mark_failure(__pos, "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]") } {
                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                __state.mark_failure(__pos, "whitespace");
                Failed
            }
        }
    }
}

fn __parse_eol_r<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let str_start = __pos;
            match slice_eq(__input, __state, __pos, "\n") {
                Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let str_start = __pos;
                    match slice_eq(__input, __state, __pos, "\r\n") {
                        Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let str_start = __pos;
                            match slice_eq(__input, __state, __pos, "\r") {
                                Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let str_start = __pos;
                                    match slice_eq(__input, __state, __pos, "\u{2028}") {
                                        Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let str_start = __pos;
                                        match slice_eq(__input, __state, __pos, "\u{2029}") {
                                            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                            Failed => Failed,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_comment<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = {
                let str_start = __pos;
                match {
                    let __seq_res = slice_eq(__input, __state, __pos, "#");
                    match __seq_res {
                        Matched(__pos, _) => {
                            {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '\n' | '\r' | '\u{2028}' | '\u{2029}' => __state.mark_failure(__pos, "[^\n\r\u{2028}\u{2029}]"),
                                                _ => Matched(__next, ()),
                                            }
                                        } else { __state.mark_failure(__pos, "[^\n\r\u{2028}\u{2029}]") };
                                        match __step_res {
                                            Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                            Failed => { break; }
                                        }
                                    }
                                    Matched(__repeat_pos, ())
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        match __parse_eol_r(__input, __state, __pos) {
                                            Matched(pos, _) => Matched(pos, ()),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                } {
                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                __state.mark_failure(__pos, "<comment>");
                Failed
            }
        }
    }
}

fn __parse_eol<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = {
                let str_start = __pos;
                match {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = match __parse_whitespace(__input, __state, __pos) {
                                Matched(pos, _) => Matched(pos, ()),
                                Failed => Failed,
                            };
                            match __step_res {
                                Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                Failed => { break; }
                            }
                        }
                        Matched(__repeat_pos, ())
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            match __parse_eol_r(__input, __state, __pos) {
                                Matched(pos, _) => Matched(pos, ()),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                } {
                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let str_start = __pos;
                        match match __parse_comment(__input, __state, __pos) {
                            Matched(pos, _) => Matched(pos, ()),
                            Failed => Failed,
                        } {
                            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        __state.mark_failure(__pos, "<newline>");
                        Failed
                    }
                }
            }
        }
    }
}

fn __parse__<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = {
                let str_start = __pos;
                match {
                    let __choice_res = match __parse_whitespace(__input, __state, __pos) {
                        Matched(pos, _) => Matched(pos, ()),
                        Failed => Failed,
                    };
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => {
                            let __choice_res = match __parse_comment(__input, __state, __pos) {
                                Matched(pos, _) => Matched(pos, ()),
                                Failed => Failed,
                            };
                            match __choice_res {
                                Matched(__pos, __value) => Matched(__pos, __value),
                                Failed => match __parse_eol_r(__input, __state, __pos) {
                                    Matched(pos, _) => Matched(pos, ()),
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                } {
                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                __state.mark_failure(__pos, "<newline> <whitespace> or <comment>");
                Failed
            }
        }
    }
}

fn __parse_field_name<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)] {
        let str_start = __pos;
        match {
            let __seq_res = if __input.len() > __pos {
                let (__ch, __next) = char_range_at(__input, __pos);
                match __ch {
                    'a'...'z' => Matched(__next, ()),
                    _ => __state.mark_failure(__pos, "[a-z]"),
                }
            } else { __state.mark_failure(__pos, "[a-z]") };
            match __seq_res {
                Matched(__pos, _) => {
                    {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = {
                                let __seq_res = match if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_]"),
                                    }
                                } else { __state.mark_failure(__pos, "[_]") } {
                                    Matched(__newpos, _) => { Matched(__newpos, ()) }
                                    Failed => { Matched(__pos, ()) }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                'a'...'z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[a-z0-9]"),
                                            }
                                        } else { __state.mark_failure(__pos, "[a-z0-9]") }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __step_res {
                                Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                Failed => { break; }
                            }
                        }
                        Matched(__repeat_pos, ())
                    }
                }
                Failed => Failed,
            }
        } {
            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
            Failed => Failed,
        }
    }
}

fn __parse_name<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)] {
        let str_start = __pos;
        match {
            let __seq_res = if __input.len() > __pos {
                let (__ch, __next) = char_range_at(__input, __pos);
                match __ch {
                    'A'...'Z' => Matched(__next, ()),
                    _ => __state.mark_failure(__pos, "[A-Z]"),
                }
            } else { __state.mark_failure(__pos, "[A-Z]") };
            match __seq_res {
                Matched(__pos, _) => {
                    {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    'A'...'Z' | 'a'...'z' | '0'...'9' | '_' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[A-Za-z0-9_]"),
                                }
                            } else { __state.mark_failure(__pos, "[A-Za-z0-9_]") };
                            match __step_res {
                                Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                Failed => { break; }
                            }
                        }
                        Matched(__repeat_pos, ())
                    }
                }
                Failed => Failed,
            }
        } {
            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
            Failed => Failed,
        }
    }
}

fn __parse_interface_name<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<&'input str> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = {
                let str_start = __pos;
                match {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec!();
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    'a'...'z' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[a-z]"),
                                }
                            } else { __state.mark_failure(__pos, "[a-z]") };
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => { break; }
                            }
                        }
                        if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec!();
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = {
                                        let __seq_res = slice_eq(__input, __state, __pos, ".");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                {
                                                    let __seq_res = {
                                                        let mut __repeat_pos = __pos;
                                                        let mut __repeat_value = vec!();
                                                        loop {
                                                            let __pos = __repeat_pos;
                                                            let __step_res = if __input.len() > __pos {
                                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                                match __ch {
                                                                    'a'...'z' | '0'...'9' => Matched(__next, ()),
                                                                    _ => __state.mark_failure(__pos, "[a-z0-9]"),
                                                                }
                                                            } else { __state.mark_failure(__pos, "[a-z0-9]") };
                                                            match __step_res {
                                                                Matched(__newpos, __value) => {
                                                                    __repeat_pos = __newpos;
                                                                    __repeat_value.push(__value);
                                                                }
                                                                Failed => { break; }
                                                            }
                                                        }
                                                        if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            {
                                                                let mut __repeat_pos = __pos;
                                                                loop {
                                                                    let __pos = __repeat_pos;
                                                                    let __step_res = {
                                                                        let __seq_res = if __input.len() > __pos {
                                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                                            match __ch {
                                                                                '-' => Matched(__next, ()),
                                                                                _ => __state.mark_failure(__pos, "[-]"),
                                                                            }
                                                                        } else { __state.mark_failure(__pos, "[-]") };
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => {
                                                                                {
                                                                                    let mut __repeat_pos = __pos;
                                                                                    let mut __repeat_value = vec!();
                                                                                    loop {
                                                                                        let __pos = __repeat_pos;
                                                                                        let __step_res = if __input.len() > __pos {
                                                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                                                            match __ch {
                                                                                                'a'...'z' | '0'...'9' => Matched(__next, ()),
                                                                                                _ => __state.mark_failure(__pos, "[a-z0-9]"),
                                                                                            }
                                                                                        } else { __state.mark_failure(__pos, "[a-z0-9]") };
                                                                                        match __step_res {
                                                                                            Matched(__newpos, __value) => {
                                                                                                __repeat_pos = __newpos;
                                                                                                __repeat_value.push(__value);
                                                                                            }
                                                                                            Failed => { break; }
                                                                                        }
                                                                                    }
                                                                                    if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    };
                                                                    match __step_res {
                                                                        Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                        Failed => { break; }
                                                                    }
                                                                }
                                                                Matched(__repeat_pos, ())
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => { break; }
                                    }
                                }
                                if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                            }
                        }
                        Failed => Failed,
                    }
                } {
                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let str_start = __pos;
                        match {
                            let __seq_res = slice_eq(__input, __state, __pos, "xn--");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec!();
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __step_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        'a'...'z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[a-z0-9]"),
                                                    }
                                                } else { __state.mark_failure(__pos, "[a-z0-9]") };
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => { break; }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value = vec!();
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __step_res = {
                                                            let __seq_res = slice_eq(__input, __state, __pos, ".");
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    {
                                                                        let __seq_res = {
                                                                            let mut __repeat_pos = __pos;
                                                                            let mut __repeat_value = vec!();
                                                                            loop {
                                                                                let __pos = __repeat_pos;
                                                                                let __step_res = if __input.len() > __pos {
                                                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                                                    match __ch {
                                                                                        'a'...'z' | '0'...'9' => Matched(__next, ()),
                                                                                        _ => __state.mark_failure(__pos, "[a-z0-9]"),
                                                                                    }
                                                                                } else { __state.mark_failure(__pos, "[a-z0-9]") };
                                                                                match __step_res {
                                                                                    Matched(__newpos, __value) => {
                                                                                        __repeat_pos = __newpos;
                                                                                        __repeat_value.push(__value);
                                                                                    }
                                                                                    Failed => { break; }
                                                                                }
                                                                            }
                                                                            if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => {
                                                                                {
                                                                                    let mut __repeat_pos = __pos;
                                                                                    loop {
                                                                                        let __pos = __repeat_pos;
                                                                                        let __step_res = {
                                                                                            let __seq_res = if __input.len() > __pos {
                                                                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                                                                match __ch {
                                                                                                    '-' => Matched(__next, ()),
                                                                                                    _ => __state.mark_failure(__pos, "[-]"),
                                                                                                }
                                                                                            } else { __state.mark_failure(__pos, "[-]") };
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => {
                                                                                                    {
                                                                                                        let mut __repeat_pos = __pos;
                                                                                                        let mut __repeat_value = vec!();
                                                                                                        loop {
                                                                                                            let __pos = __repeat_pos;
                                                                                                            let __step_res = if __input.len() > __pos {
                                                                                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                                                                                match __ch {
                                                                                                                    'a'...'z' | '0'...'9' => Matched(__next, ()),
                                                                                                                    _ => __state.mark_failure(__pos, "[a-z0-9]"),
                                                                                                                }
                                                                                                            } else { __state.mark_failure(__pos, "[a-z0-9]") };
                                                                                                            match __step_res {
                                                                                                                Matched(__newpos, __value) => {
                                                                                                                    __repeat_pos = __newpos;
                                                                                                                    __repeat_value.push(__value);
                                                                                                                }
                                                                                                                Failed => { break; }
                                                                                                            }
                                                                                                        }
                                                                                                        if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        };
                                                                                        match __step_res {
                                                                                            Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                                            Failed => { break; }
                                                                                        }
                                                                                    }
                                                                                    Matched(__repeat_pos, ())
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __step_res {
                                                            Matched(__newpos, __value) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            Failed => { break; }
                                                        }
                                                    }
                                                    if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        __state.mark_failure(__pos, "<reverse domain name>");
                        Failed
                    }
                }
            }
        }
    }
}

fn __parse_array<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<()> { #![allow(non_snake_case, unused)] slice_eq(__input, __state, __pos, "[]") }

fn __parse_dict<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<()> { #![allow(non_snake_case, unused)] slice_eq(__input, __state, __pos, "[string]") }

fn __parse_option<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<()> { #![allow(non_snake_case, unused)] slice_eq(__input, __state, __pos, "?") }

fn __parse_btype<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<VTypeExt<'input>> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "bool");
            match __seq_res {
                Matched(__pos, _) => { Matched(__pos, { VTypeExt::Plain(VType::Bool) }) }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "int");
                    match __seq_res {
                        Matched(__pos, _) => { Matched(__pos, { VTypeExt::Plain(VType::Int) }) }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "float");
                            match __seq_res {
                                Matched(__pos, _) => { Matched(__pos, { VTypeExt::Plain(VType::Float) }) }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "string");
                                    match __seq_res {
                                        Matched(__pos, _) => { Matched(__pos, { VTypeExt::Plain(VType::String) }) }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "object");
                                            match __seq_res {
                                                Matched(__pos, _) => { Matched(__pos, { VTypeExt::Plain(VType::Object) }) }
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res = {
                                                    let __seq_res = {
                                                        let str_start = __pos;
                                                        match match __parse_name(__input, __state, __pos) {
                                                            Matched(pos, _) => Matched(pos, ()),
                                                            Failed => Failed,
                                                        } {
                                                            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, t) => { Matched(__pos, { VTypeExt::Plain(VType::Typename(t)) }) }
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __choice_res {
                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                    Failed => {
                                                        let __choice_res = {
                                                            let __seq_res = __parse_vstruct(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, v) => { Matched(__pos, { VTypeExt::Plain(VType::Struct(Box::new(v))) }) }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __choice_res {
                                                            Matched(__pos, __value) => Matched(__pos, __value),
                                                            Failed => {
                                                                let __seq_res = __parse_venum(__input, __state, __pos);
                                                                match __seq_res {
                                                                    Matched(__pos, v) => { Matched(__pos, { VTypeExt::Plain(VType::Enum(Box::new(v))) }) }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_type<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<VTypeExt<'input>> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            let __seq_res = __parse_btype(__input, __state, __pos);
            match __seq_res {
                Matched(__pos, v) => { Matched(__pos, { v }) }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_array(__input, __state, __pos);
                    match __seq_res {
                        Matched(__pos, a) => {
                            {
                                let __seq_res = __parse_type(__input, __state, __pos);
                                match __seq_res {
                                    Matched(__pos, v) => { Matched(__pos, { VTypeExt::Array(Box::new(v)) }) }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = __parse_dict(__input, __state, __pos);
                            match __seq_res {
                                Matched(__pos, a) => {
                                    {
                                        let __seq_res = __parse_type(__input, __state, __pos);
                                        match __seq_res {
                                            Matched(__pos, v) => { Matched(__pos, { VTypeExt::Dict(Box::new(v)) }) }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = __parse_option(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            {
                                                let __seq_res = __parse_btype(__input, __state, __pos);
                                                match __seq_res {
                                                    Matched(__pos, v) => { Matched(__pos, { VTypeExt::Option(Box::new(v)) }) }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = __parse_option(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, o) => {
                                                    {
                                                        let __seq_res = __parse_array(__input, __state, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, a) => {
                                                                {
                                                                    let __seq_res = __parse_type(__input, __state, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, v) => { Matched(__pos, { VTypeExt::Option(Box::new(VTypeExt::Array(Box::new(v)))) }) }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __seq_res = __parse_option(__input, __state, __pos);
                                                match __seq_res {
                                                    Matched(__pos, o) => {
                                                        {
                                                            let __seq_res = __parse_dict(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, a) => {
                                                                    {
                                                                        let __seq_res = __parse_type(__input, __state, __pos);
                                                                        match __seq_res {
                                                                            Matched(__pos, v) => { Matched(__pos, { VTypeExt::Option(Box::new(VTypeExt::Dict(Box::new(v)))) }) }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_object_field<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<Argument<'input>> {
    #![allow(non_snake_case, unused)] {
        let __seq_res = {
            let mut __repeat_pos = __pos;
            loop {
                let __pos = __repeat_pos;
                let __step_res = match __parse__(__input, __state, __pos) {
                    Matched(pos, _) => Matched(pos, ()),
                    Failed => Failed,
                };
                match __step_res {
                    Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                    Failed => { break; }
                }
            }
            Matched(__repeat_pos, ())
        };
        match __seq_res {
            Matched(__pos, _) => {
                {
                    let __seq_res = {
                        let str_start = __pos;
                        match match __parse_field_name(__input, __state, __pos) {
                            Matched(pos, _) => Matched(pos, ()),
                            Failed => Failed,
                        } {
                            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, n) => {
                            {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = match __parse__(__input, __state, __pos) {
                                            Matched(pos, _) => Matched(pos, ()),
                                            Failed => Failed,
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                            Failed => { break; }
                                        }
                                    }
                                    Matched(__repeat_pos, ())
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        {
                                            let __seq_res = slice_eq(__input, __state, __pos, ":");
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    {
                                                        let __seq_res = {
                                                            let mut __repeat_pos = __pos;
                                                            loop {
                                                                let __pos = __repeat_pos;
                                                                let __step_res = match __parse__(__input, __state, __pos) {
                                                                    Matched(pos, _) => Matched(pos, ()),
                                                                    Failed => Failed,
                                                                };
                                                                match __step_res {
                                                                    Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                    Failed => { break; }
                                                                }
                                                            }
                                                            Matched(__repeat_pos, ())
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                {
                                                                    let __seq_res = __parse_type(__input, __state, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, v) => { Matched(__pos, { Argument { name: n, vtype: v } }) }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_vstruct<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<VStruct<'input>> {
    #![allow(non_snake_case, unused)] {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = match __parse__(__input, __state, __pos) {
                                Matched(pos, _) => Matched(pos, ()),
                                Failed => Failed,
                            };
                            match __step_res {
                                Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                Failed => { break; }
                            }
                        }
                        Matched(__repeat_pos, ())
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec!();
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __pos = if __repeat_value.len() > 0 {
                                            let __sep_res = slice_eq(__input, __state, __pos, ",");
                                            match __sep_res {
                                                Matched(__newpos, _) => { __newpos }
                                                Failed => break,
                                            }
                                        } else { __pos };
                                        let __step_res = __parse_object_field(__input, __state, __pos);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => { break; }
                                        }
                                    }
                                    Matched(__repeat_pos, __repeat_value)
                                };
                                match __seq_res {
                                    Matched(__pos, e) => {
                                        {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __step_res = match __parse__(__input, __state, __pos) {
                                                        Matched(pos, _) => Matched(pos, ()),
                                                        Failed => Failed,
                                                    };
                                                    match __step_res {
                                                        Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                        Failed => { break; }
                                                    }
                                                }
                                                Matched(__repeat_pos, ())
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => { Matched(__pos, { VStruct { elts: e } }) }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_venum<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<VEnum<'input>> {
    #![allow(non_snake_case, unused)] {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = match __parse__(__input, __state, __pos) {
                                Matched(pos, _) => Matched(pos, ()),
                                Failed => Failed,
                            };
                            match __step_res {
                                Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                Failed => { break; }
                            }
                        }
                        Matched(__repeat_pos, ())
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec!();
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __pos = if __repeat_value.len() > 0 {
                                            let __sep_res = {
                                                let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        {
                                                            let mut __repeat_pos = __pos;
                                                            loop {
                                                                let __pos = __repeat_pos;
                                                                let __step_res = match __parse__(__input, __state, __pos) {
                                                                    Matched(pos, _) => Matched(pos, ()),
                                                                    Failed => Failed,
                                                                };
                                                                match __step_res {
                                                                    Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                    Failed => { break; }
                                                                }
                                                            }
                                                            Matched(__repeat_pos, ())
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __sep_res {
                                                Matched(__newpos, _) => { __newpos }
                                                Failed => break,
                                            }
                                        } else { __pos };
                                        let __step_res = __parse_field_name(__input, __state, __pos);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => { break; }
                                        }
                                    }
                                    Matched(__repeat_pos, __repeat_value)
                                };
                                match __seq_res {
                                    Matched(__pos, v) => {
                                        {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __step_res = match __parse__(__input, __state, __pos) {
                                                        Matched(pos, _) => Matched(pos, ()),
                                                        Failed => Failed,
                                                    };
                                                    match __step_res {
                                                        Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                        Failed => { break; }
                                                    }
                                                }
                                                Matched(__repeat_pos, ())
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => { Matched(__pos, { VEnum { elts: v } }) }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_vtypedef<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<Typedef<'input>> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            let __seq_res = {
                let str_start = __pos;
                match {
                    let mut __repeat_pos = __pos;
                    loop {
                        let __pos = __repeat_pos;
                        let __step_res = match __parse__(__input, __state, __pos) {
                            Matched(pos, _) => Matched(pos, ()),
                            Failed => Failed,
                        };
                        match __step_res {
                            Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                            Failed => { break; }
                        }
                    }
                    Matched(__repeat_pos, ())
                } {
                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, d) => {
                    {
                        let __seq_res = slice_eq(__input, __state, __pos, "type");
                        match __seq_res {
                            Matched(__pos, _) => {
                                {
                                    let __seq_res = {
                                        let mut __repeat_pos = __pos;
                                        let mut __repeat_value = vec!();
                                        loop {
                                            let __pos = __repeat_pos;
                                            let __step_res = match __parse__(__input, __state, __pos) {
                                                Matched(pos, _) => Matched(pos, ()),
                                                Failed => Failed,
                                            };
                                            match __step_res {
                                                Matched(__newpos, __value) => {
                                                    __repeat_pos = __newpos;
                                                    __repeat_value.push(__value);
                                                }
                                                Failed => { break; }
                                            }
                                        }
                                        if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            {
                                                let __seq_res = {
                                                    let str_start = __pos;
                                                    match match __parse_name(__input, __state, __pos) {
                                                        Matched(pos, _) => Matched(pos, ()),
                                                        Failed => Failed,
                                                    } {
                                                        Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, n) => {
                                                        {
                                                            let __seq_res = {
                                                                let mut __repeat_pos = __pos;
                                                                loop {
                                                                    let __pos = __repeat_pos;
                                                                    let __step_res = match __parse__(__input, __state, __pos) {
                                                                        Matched(pos, _) => Matched(pos, ()),
                                                                        Failed => Failed,
                                                                    };
                                                                    match __step_res {
                                                                        Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                        Failed => { break; }
                                                                    }
                                                                }
                                                                Matched(__repeat_pos, ())
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    {
                                                                        let __seq_res = __parse_vstruct(__input, __state, __pos);
                                                                        match __seq_res {
                                                                            Matched(__pos, v) => {
                                                                                Matched(__pos, {
                                                                                    Typedef { name: n, doc: trim_doc(d), elt: VStructOrEnum::VStruct(Box::new(v)) }
                                                                                })
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = match __parse__(__input, __state, __pos) {
                                Matched(pos, _) => Matched(pos, ()),
                                Failed => Failed,
                            };
                            match __step_res {
                                Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                Failed => { break; }
                            }
                        }
                        Matched(__repeat_pos, ())
                    } {
                        Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, d) => {
                        {
                            let __seq_res = slice_eq(__input, __state, __pos, "type");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec!();
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __step_res = match __parse__(__input, __state, __pos) {
                                                    Matched(pos, _) => Matched(pos, ()),
                                                    Failed => Failed,
                                                };
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => { break; }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                {
                                                    let __seq_res = {
                                                        let str_start = __pos;
                                                        match match __parse_name(__input, __state, __pos) {
                                                            Matched(pos, _) => Matched(pos, ()),
                                                            Failed => Failed,
                                                        } {
                                                            Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, n) => {
                                                            {
                                                                let __seq_res = {
                                                                    let mut __repeat_pos = __pos;
                                                                    loop {
                                                                        let __pos = __repeat_pos;
                                                                        let __step_res = match __parse__(__input, __state, __pos) {
                                                                            Matched(pos, _) => Matched(pos, ()),
                                                                            Failed => Failed,
                                                                        };
                                                                        match __step_res {
                                                                            Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                            Failed => { break; }
                                                                        }
                                                                    }
                                                                    Matched(__repeat_pos, ())
                                                                };
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        {
                                                                            let __seq_res = __parse_venum(__input, __state, __pos);
                                                                            match __seq_res {
                                                                                Matched(__pos, v) => {
                                                                                    Matched(__pos, {
                                                                                        Typedef { name: n, doc: trim_doc(d), elt: VStructOrEnum::VEnum(Box::new(v)) }
                                                                                    })
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_error<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<VError<'input>> {
    #![allow(non_snake_case, unused)] {
        let __seq_res = {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = match __parse__(__input, __state, __pos) {
                        Matched(pos, _) => Matched(pos, ()),
                        Failed => Failed,
                    };
                    match __step_res {
                        Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                        Failed => { break; }
                    }
                }
                Matched(__repeat_pos, ())
            } {
                Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, d) => {
                {
                    let __seq_res = slice_eq(__input, __state, __pos, "error");
                    match __seq_res {
                        Matched(__pos, _) => {
                            {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec!();
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = match __parse__(__input, __state, __pos) {
                                            Matched(pos, _) => Matched(pos, ()),
                                            Failed => Failed,
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => { break; }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        {
                                            let __seq_res = {
                                                let str_start = __pos;
                                                match match __parse_name(__input, __state, __pos) {
                                                    Matched(pos, _) => Matched(pos, ()),
                                                    Failed => Failed,
                                                } {
                                                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, n) => {
                                                    {
                                                        let __seq_res = {
                                                            let mut __repeat_pos = __pos;
                                                            loop {
                                                                let __pos = __repeat_pos;
                                                                let __step_res = match __parse__(__input, __state, __pos) {
                                                                    Matched(pos, _) => Matched(pos, ()),
                                                                    Failed => Failed,
                                                                };
                                                                match __step_res {
                                                                    Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                    Failed => { break; }
                                                                }
                                                            }
                                                            Matched(__repeat_pos, ())
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                {
                                                                    let __seq_res = __parse_vstruct(__input, __state, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, p) => { Matched(__pos, { VError { name: n, doc: trim_doc(d), parm: p } }) }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_method<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<Method<'input>> {
    #![allow(non_snake_case, unused)] {
        let __seq_res = {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = match __parse__(__input, __state, __pos) {
                        Matched(pos, _) => Matched(pos, ()),
                        Failed => Failed,
                    };
                    match __step_res {
                        Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                        Failed => { break; }
                    }
                }
                Matched(__repeat_pos, ())
            } {
                Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, d) => {
                {
                    let __seq_res = slice_eq(__input, __state, __pos, "method");
                    match __seq_res {
                        Matched(__pos, _) => {
                            {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec!();
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = match __parse__(__input, __state, __pos) {
                                            Matched(pos, _) => Matched(pos, ()),
                                            Failed => Failed,
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => { break; }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        {
                                            let __seq_res = {
                                                let str_start = __pos;
                                                match match __parse_name(__input, __state, __pos) {
                                                    Matched(pos, _) => Matched(pos, ()),
                                                    Failed => Failed,
                                                } {
                                                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, n) => {
                                                    {
                                                        let __seq_res = {
                                                            let mut __repeat_pos = __pos;
                                                            loop {
                                                                let __pos = __repeat_pos;
                                                                let __step_res = match __parse__(__input, __state, __pos) {
                                                                    Matched(pos, _) => Matched(pos, ()),
                                                                    Failed => Failed,
                                                                };
                                                                match __step_res {
                                                                    Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                    Failed => { break; }
                                                                }
                                                            }
                                                            Matched(__repeat_pos, ())
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                {
                                                                    let __seq_res = __parse_vstruct(__input, __state, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, i) => {
                                                                            {
                                                                                let __seq_res = {
                                                                                    let mut __repeat_pos = __pos;
                                                                                    loop {
                                                                                        let __pos = __repeat_pos;
                                                                                        let __step_res = match __parse__(__input, __state, __pos) {
                                                                                            Matched(pos, _) => Matched(pos, ()),
                                                                                            Failed => Failed,
                                                                                        };
                                                                                        match __step_res {
                                                                                            Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                                            Failed => { break; }
                                                                                        }
                                                                                    }
                                                                                    Matched(__repeat_pos, ())
                                                                                };
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        {
                                                                                            let __seq_res = slice_eq(__input, __state, __pos, "->");
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => {
                                                                                                    {
                                                                                                        let __seq_res = {
                                                                                                            let mut __repeat_pos = __pos;
                                                                                                            loop {
                                                                                                                let __pos = __repeat_pos;
                                                                                                                let __step_res = match __parse__(__input, __state, __pos) {
                                                                                                                    Matched(pos, _) => Matched(pos, ()),
                                                                                                                    Failed => Failed,
                                                                                                                };
                                                                                                                match __step_res {
                                                                                                                    Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                                                                    Failed => { break; }
                                                                                                                }
                                                                                                            }
                                                                                                            Matched(__repeat_pos, ())
                                                                                                        };
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, _) => {
                                                                                                                {
                                                                                                                    let __seq_res = __parse_vstruct(__input, __state, __pos);
                                                                                                                    match __seq_res {
                                                                                                                        Matched(__pos, o) => {
                                                                                                                            Matched(__pos, {
                                                                                                                                Method {
                                                                                                                                    name: n,
                                                                                                                                    doc: trim_doc(d),
                                                                                                                                    input: i,
                                                                                                                                    output: o,
                                                                                                                                }
                                                                                                                            })
                                                                                                                        }
                                                                                                                        Failed => Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_member<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<MethodOrTypedefOrError<'input>> {
    #![allow(non_snake_case, unused)] {
        let __choice_res = {
            let __seq_res = __parse_method(__input, __state, __pos);
            match __seq_res {
                Matched(__pos, m) => { Matched(__pos, { MethodOrTypedefOrError::Method(m) }) }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_vtypedef(__input, __state, __pos);
                    match __seq_res {
                        Matched(__pos, t) => { Matched(__pos, { MethodOrTypedefOrError::Typedef(t) }) }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = __parse_error(__input, __state, __pos);
                        match __seq_res {
                            Matched(__pos, e) => { Matched(__pos, { MethodOrTypedefOrError::Error(e) }) }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_VInterface<'input>(__input: &'input str, __state: &mut ParseState<'input>, __pos: usize) -> RuleResult<Interface<'input>> {
    #![allow(non_snake_case, unused)] {
        let __seq_res = {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = match __parse__(__input, __state, __pos) {
                        Matched(pos, _) => Matched(pos, ()),
                        Failed => Failed,
                    };
                    match __step_res {
                        Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                        Failed => { break; }
                    }
                }
                Matched(__repeat_pos, ())
            } {
                Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, d) => {
                {
                    let __seq_res = slice_eq(__input, __state, __pos, "interface");
                    match __seq_res {
                        Matched(__pos, _) => {
                            {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec!();
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = match __parse__(__input, __state, __pos) {
                                            Matched(pos, _) => Matched(pos, ()),
                                            Failed => Failed,
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => { break; }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 { Matched(__repeat_pos, ()) } else { Failed }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        {
                                            let __seq_res = {
                                                let str_start = __pos;
                                                match match __parse_interface_name(__input, __state, __pos) {
                                                    Matched(pos, _) => Matched(pos, ()),
                                                    Failed => Failed,
                                                } {
                                                    Matched(__newpos, _) => { Matched(__newpos, &__input[str_start..__newpos]) }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, n) => {
                                                    {
                                                        let __seq_res = match __parse_eol(__input, __state, __pos) {
                                                            Matched(pos, _) => Matched(pos, ()),
                                                            Failed => Failed,
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                {
                                                                    let __seq_res = {
                                                                        let mut __repeat_pos = __pos;
                                                                        let mut __repeat_value = vec!();
                                                                        loop {
                                                                            let __pos = __repeat_pos;
                                                                            let __pos = if __repeat_value.len() > 0 {
                                                                                let __sep_res = match __parse_eol(__input, __state, __pos) {
                                                                                    Matched(pos, _) => Matched(pos, ()),
                                                                                    Failed => Failed,
                                                                                };
                                                                                match __sep_res {
                                                                                    Matched(__newpos, _) => { __newpos }
                                                                                    Failed => break,
                                                                                }
                                                                            } else { __pos };
                                                                            let __step_res = __parse_member(__input, __state, __pos);
                                                                            match __step_res {
                                                                                Matched(__newpos, __value) => {
                                                                                    __repeat_pos = __newpos;
                                                                                    __repeat_value.push(__value);
                                                                                }
                                                                                Failed => { break; }
                                                                            }
                                                                        }
                                                                        if __repeat_value.len() >= 1 { Matched(__repeat_pos, __repeat_value) } else { Failed }
                                                                    };
                                                                    match __seq_res {
                                                                        Matched(__pos, mt) => {
                                                                            {
                                                                                let __seq_res = {
                                                                                    let mut __repeat_pos = __pos;
                                                                                    loop {
                                                                                        let __pos = __repeat_pos;
                                                                                        let __step_res = match __parse__(__input, __state, __pos) {
                                                                                            Matched(pos, _) => Matched(pos, ()),
                                                                                            Failed => Failed,
                                                                                        };
                                                                                        match __step_res {
                                                                                            Matched(__newpos, __value) => { __repeat_pos = __newpos; }
                                                                                            Failed => { break; }
                                                                                        }
                                                                                    }
                                                                                    Matched(__repeat_pos, ())
                                                                                };
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        Matched(__pos, {
                                                                                            Interface::from_token(n, mt, trim_doc(d))
                                                                                        })
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}

pub fn VInterface<'input>(__input: &'input str) -> ParseResult<Interface<'input>> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_VInterface(__input, &mut __state, 0) {
        Matched(__pos, __value) => { if __pos == __input.len() { return Ok(__value); } }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError { line: __line, column: __col, offset: __state.max_err_pos, expected: __state.expected })
}